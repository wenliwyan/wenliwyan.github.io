---
layout: post
title: Manipulating Data with Labels in Pandas
---

Pandas is probably the most widely used Python package for handling tabular data. Although I hated using Pandas for quite some time (fun fact) due to its cumbersome and unintuitive usage compared to the straightforward transformations achievable with NumPy arrays, my perspective shifted over time. I came to recognize its strengths, particularly when confronted with CSV files. From my perspective, Pandas' defining feature lies in its use of labels, encompassing both row and column labels. Unlike NumPy arrays, where manipulating elements requires numeric indices devoid of contextual meaning, Pandas utilizes labels that provide explicit meaning to the data, thereby preventing users from getting lost in mere numbers.

While I maintain a preference for NumPy to execute array transformations, the utilization of Pandas becomes essential when working with labels. This post serves as a repository for the practical applications that I have collected while working with Pandas labels, offering a convenient reference for future.

## pandas.Index

[pandas.Index](https://pandas.pydata.org/docs/reference/api/pandas.Index.html) is the data structure to store a series of labels in Pandas. For row labels, the `pandas.Index` object is called `index`, and for column labels, it's called `columns`. Note here index becomes an overloaded term. To differentiate them clearly, this post adds `pandas.` prefix explicitly when referring to the class underlying both row and column labels, and use index directly when referring to row labels.

```python
In : df = pd.DataFrame({"unit": ["a", "a", "b", "c", "c"],
                        "time": [0, 1, 1, 0, 1],
                        "value": [10, 15, 5, 8, 12]})
In : df
Out: 
  unit  time  value
0    a     0     10
1    a     1     15
2    b     1      5
3    c     0      8
4    c     1     12

In : df.index
Out: RangeIndex(start=0, stop=5, step=1)

In : df.columns  
Out: Index(['unit', 'time', 'value'], dtype='object')
```

In specific use cases, there are subclasses of `pandas.Index` to save memory and improve computing speed, such as [`RangeIndex`](https://pandas.pydata.org/docs/reference/api/pandas.RangeIndex.html) for monotonic integer labels, and [`MultiIndex`](https://pandas.pydata.org/docs/reference/api/pandas.MultiIndex.html) for multi-level labels.

Member variables in `pandas.Index` class include:
* `name`: str, the name (category) of all labels
* `names`: Pandas `FrozenList` of str, the name (category) of all labels in each level. The length of names equals the number of levels.
* `values`: NumPy ndarray, the actual labels

```python
In : print(df.columns.name)
None

In : df.columns.names
Out: FrozenList([None])

In : df.columns.values
Out: array(['unit', 'time', 'value'], dtype=object)
```

The name and names are usually empty unless explicitly set to provide more contextual meaning. An example with concrete names be found latter in multi-level labels.

### index

This section expands further for row labels specifically.

When creating a [`DataFrame`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.html#pandas.DataFrame) (2-dimensional data) or a [`Series`](https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.Series.html#pandas.Series) (1-dimensional data), if the input data contains no indexing information and index is not explicitly provided either, its index defaults to `RangeIndex`.

The index can be changed by `set_index(keys)`. Providing a column name instructs using an existing column as index.

```python
In : multi_index_df = df.set_index(["unit", "time"])
In : multi_index_df
Out: 
           value
unit time       
a    0        10
     1        15
b    1         5
c    0         8
     1        12
```

To change back to the sequential numerical index of `RangeIndex`, `reset_index()` is used. The default adds the old index as a column with the index name (if the index name is empty, the new column name is set to "index"). In use cases such as numerical index becomes nuisance after reordering or filtering the rows, set `drop=True` parameter to completely drop the old index.

```python
In : df[df["time"] == 1]
Out: 
  unit  time  value
1    a     1     15
2    b     1      5
4    c     1     12

In : df[df["time"] == 1].reset_index()
Out: 
   index unit  time  value
0      1    a     1     15
1      2    b     1      5
2      4    c     1     12

In : df[df["time"] == 1].reset_index(drop=True)
Out: 
  unit  time  value
0    a     1     15
1    b     1      5
2    c     1     12

In : df.sort_values(by="value", ignore_index=True)  # ignore_index introduced in pandas version >1.0
# equivalent to df.sort_values(by="value").reset_index(drop=True)
Out:
  unit  time  value
0    b     1      5
1    c     0      8
2    a     0     10
3    c     1     12
4    a     1     15
```

### access data

`loc` uses labels to access data, while `iloc` uses positions to access data.

## MultiIndex

`MultiIndex` is the subclass of `pandas.Index` for multi-level labels. It can be used for both row and column labels.

To create a DataFrame with multi-level index, you can use `set_index` to set multiple columns as the index. To explicitly create a `MultiIndex` object, you can use its class functions to construct it from arrays, tuples, and products (ref: <https://pandas.pydata.org/pandas-docs/stable/user_guide/advanced.html#creating-a-multiindex-hierarchical-index-object>).

Following the example of `multi_index_df` in `set_index`:

```python
In : multi_index_df.index.levels  # levels are member variable in MultiIndex but not in Index
Out[105]: FrozenList([['a', 'b', 'c'], [0, 1]])

In : multi_index_df.index.values
Out: array([('a', 0), ('a', 1), ('b', 1), ('c', 0), ('c', 1)], dtype=object)

In : full_cartesian_multi_index = pd.MultiIndex.from_product(multi_index_df.index.levels)

In : full_cartesian_multi_index.levels
Out: FrozenList([['a', 'b', 'c'], [0, 1]])

In : full_cartesian_multi_index.values
Out: 
array([('a', 0), ('a', 1), ('b', 0), ('b', 1), ('c', 0), ('c', 1)], dtype=object)

In : multi_index_df.reindex(full_cartesian_multi_index)                                 
Out: 
     value
a 0   10.0
  1   15.0
b 0    NaN
  1    5.0
c 0    8.0
  1   12.0
```

To get the labels of one level, use `get_level_values(level)` by providing its integer position or its level name.

After slicing a MultiIndex (and a DataFrame with MultiIndex), the MultiIndex levels keep the same (as Pandas `FrozenList`), so there could be useless labels that the data subset does not need. In this case, use `remove_unused_levels` to clean up the multi-level labels.

```python
In : mi = pd.MultiIndex.from_product([range(2), list('ab')])

In : mi
Out: 
MultiIndex([(0, 'a'),
            (0, 'b'),
            (1, 'a'),
            (1, 'b')],
           )

In : mi[2:]
Out: 
MultiIndex([(1, 'a'),
            (1, 'b')],
           )

In : mi[2:].levels  # the levels keep the same as the original MultiIndex
Out: FrozenList([[0, 1], ['a', 'b']])

In : mi[2:].remove_unused_levels().levels
Out: FrozenList([[1], ['a', 'b']])
```

## Data Shape Transformations

* long to wide: pivot

```python
wide_data = long_data.pivot(index="unit", columns="period")
```

* wide to long: stack

``python
long_data = wide_data.stack().reset_index()
```